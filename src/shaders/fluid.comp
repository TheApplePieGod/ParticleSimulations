#version 450

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

struct cell
{
    int type;
    float mass;
};

layout(push_constant) uniform PushConstants {
    int numCells;
    int mapWidth;
    int mapHeight;
    int iterations;
    float diffusion;
    float viscosity;
    float deltaTime;
    bool dirty;
} constants;

layout(set = 0, binding = 0, std430) buffer CellData
{
    cell cells[];
} data;

layout(set = 0, binding = 1, std430) buffer TempData
{
    cell cells[];
} tempData;

uint ID(uint x, uint y)
{
    return y * constants.mapWidth + x;
}

float maxMass = 1.0;
float maxCompress = 0.01;
float minMass = 0.0001;
float minFlow = 0.01;
float maxSpeed = 1.0;

float get_stable_state_b(float totalMass)
{
    if ( totalMass <= 1 ){
        return 1.0;
    } else if ( totalMass < 2*maxMass + maxCompress ){
        return (maxMass*maxMass + totalMass*maxCompress)/(maxMass + maxCompress);
    } else {
        return (totalMass + maxCompress)/2;
    }
}

void main()
{
    uint id = ID(gl_GlobalInvocationID.x, gl_GlobalInvocationID.y);
    if (id >= constants.numCells || data.cells[id].type == 1) return;

    float waterVal = data.cells[id].mass;
    float flow = 0;

    if (waterVal <= 0) return;

    // down
    uint belowId = ID(gl_GlobalInvocationID.x, gl_GlobalInvocationID.y + 1);
    if (belowId < constants.numCells && data.cells[belowId].type != 1)
    {
        flow = get_stable_state_b(waterVal + data.cells[belowId].mass) - data.cells[belowId].mass;
        if (flow > minFlow)
            flow *= 0.5;
        flow = clamp(flow, 0, min(maxSpeed, waterVal));
        tempData.cells[id].mass -= flow;
        tempData.cells[belowId].mass += flow;
        waterVal -= flow;
    }

    // up
    uint aboveId = ID(gl_GlobalInvocationID.x, gl_GlobalInvocationID.y - 1);
    if (aboveId >= constants.numCells && data.cells[belowId].type != 1)
    {
        flow = get_stable_state_b(waterVal + data.cells[aboveId].mass);
        if (flow > minFlow)
            flow *= 0.5;
        flow = clamp(flow, 0, min(maxSpeed, waterVal));
        tempData.cells[id].mass -= flow;
        tempData.cells[aboveId].mass += flow;
        waterVal -= flow;
    }

    float flowAmount = 0.25;
    uvec2 offsets[2] = uvec2[](uvec2(1, 0), uvec2(-1, 0));
    for (int i = 0; i < 2; i++)
    {
        uvec2 offset = offsets[i];
        uint offsetId = ID(gl_GlobalInvocationID.x + offset.x, gl_GlobalInvocationID.y + offset.y);
        if (offsetId < constants.numCells && offsetId >= 0 && data.cells[offsetId].type != 1)
        {
            flow = (data.cells[id].mass - data.cells[offsetId].mass) * flowAmount;
            if (flow > minFlow)
                flow *= 0.5;
            flow = clamp(flow, 0, waterVal);
            tempData.cells[id].mass -= flow;
            tempData.cells[offsetId].mass += flow;
            waterVal -= flow;
        }

        if (waterVal <= 0) return;
    }
}